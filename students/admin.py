from django.contrib import admin
from django.utils.html import format_html
from django.utils import timezone
from django.http import HttpResponse
from django.db.models import Count, Avg, Q
from datetime import timedelta
from .models import StudentProfile, QuestionAttempt, RegistrationCode, LoginHistory, UserSession


@admin.register(StudentProfile)
class StudentProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'total_score', 'lessons_completed', 'last_activity')
    search_fields = ('user__username', 'user__email')
    readonly_fields = ('last_activity',)
    actions = ['generate_daily_report', 'generate_weekly_report']

    def _generate_report(self, request, queryset, days=1):
        """Helper method to generate activity report"""
        # Calculate date range
        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        # Get attempts in the date range, excluding the admin user
        attempts_in_period = QuestionAttempt.objects.filter(
            attempted_at__gte=start_date,
            attempted_at__lte=end_date
        ).exclude(student__user=request.user)

        # If specific students selected, filter to those
        if queryset.exists():
            attempts_in_period = attempts_in_period.filter(student__in=queryset)

        # Overall statistics
        total_attempts = attempts_in_period.count()
        correct_attempts = attempts_in_period.filter(is_correct=True).count()
        accuracy = (correct_attempts / total_attempts * 100) if total_attempts > 0 else 0

        # Topics worked on
        topics_data = attempts_in_period.values(
            'question__topic__name'
        ).annotate(
            attempt_count=Count('id'),
            correct_count=Count('id', filter=Q(is_correct=True)),
            avg_score=Avg('score_awarded')
        ).order_by('-attempt_count')

        # Unique questions
        unique_questions = attempts_in_period.values('question__id').distinct().count()

        # Per-student breakdown
        student_stats = []
        students_to_report = queryset if queryset.exists() else StudentProfile.objects.exclude(user=request.user)

        for student in students_to_report:
            student_attempts = attempts_in_period.filter(student=student)
            attempt_count = student_attempts.count()

            if attempt_count > 0:
                correct_count = student_attempts.filter(is_correct=True).count()
                student_accuracy = (correct_count / attempt_count * 100) if attempt_count > 0 else 0
                avg_score = student_attempts.aggregate(Avg('score_awarded'))['score_awarded__avg'] or 0

                student_topics = student_attempts.values(
                    'question__topic__name'
                ).annotate(count=Count('id')).order_by('-count')

                student_stats.append({
                    'username': student.user.username,
                    'full_name': student.user.get_full_name() or student.user.username,
                    'attempt_count': attempt_count,
                    'correct_count': correct_count,
                    'accuracy': student_accuracy,
                    'avg_score': avg_score,
                    'topics': list(student_topics),
                    'total_score': student.total_score,
                    'lessons_completed': student.lessons_completed,
                })

        student_stats.sort(key=lambda x: x['attempt_count'], reverse=True)

        # Generate text report
        lines = []
        lines.append('=' * 70)
        lines.append(f'STUDENT ACTIVITY REPORT ({days} DAY{"S" if days > 1 else ""})')
        lines.append('=' * 70)
        lines.append(f"Period: {start_date.strftime('%Y-%m-%d %H:%M')} to {end_date.strftime('%Y-%m-%d %H:%M')}")
        lines.append(f"Generated by: {request.user.username}")
        lines.append(f"Excluded user: {request.user.username}")
        if queryset.exists():
            lines.append(f"Filtered to {queryset.count()} selected student(s)")
        lines.append('')

        lines.append('-' * 70)
        lines.append('OVERALL SUMMARY')
        lines.append('-' * 70)
        lines.append(f"Active Students: {len(student_stats)}")
        lines.append(f"Total Attempts: {total_attempts}")
        lines.append(f"Correct Answers: {correct_attempts}")
        lines.append(f"Overall Accuracy: {accuracy:.1f}%")
        lines.append(f"Unique Questions Attempted: {unique_questions}")
        lines.append('')

        if topics_data:
            lines.append('-' * 70)
            lines.append('TOPICS WORKED ON')
            lines.append('-' * 70)
            lines.append(f"{'Topic':<30} {'Attempts':<10} {'Correct':<10} {'Avg Score':<10}")
            lines.append('-' * 70)
            for topic in topics_data:
                topic_name = topic['question__topic__name'] or 'Uncategorized'
                lines.append(
                    f"{topic_name:<30} {topic['attempt_count']:<10} "
                    f"{topic['correct_count']:<10} {topic['avg_score']:.1f}%"
                )
            lines.append('')

        if student_stats:
            lines.append('-' * 70)
            lines.append('STUDENT BREAKDOWN')
            lines.append('-' * 70)
            for student in student_stats:
                lines.append(f"\n{student['full_name']} ({student['username']})")
                lines.append(f"  Attempts: {student['attempt_count']}")
                lines.append(f"  Correct: {student['correct_count']} ({student['accuracy']:.1f}%)")
                lines.append(f"  Average Score: {student['avg_score']:.1f}%")
                lines.append(f"  Total Score (cumulative): {student['total_score']}")
                lines.append(f"  Lessons Completed (cumulative): {student['lessons_completed']}")

                if student['topics']:
                    lines.append(f"  Topics:")
                    for topic in student['topics'][:5]:
                        topic_name = topic['question__topic__name'] or 'Uncategorized'
                        lines.append(f"    - {topic_name}: {topic['count']} attempts")
        else:
            lines.append('No student activity in this period.')

        lines.append('')
        lines.append('=' * 70)
        lines.append(f"Report generated at: {timezone.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append('=' * 70)

        report_text = '\n'.join(lines)

        # Return as downloadable text file
        response = HttpResponse(report_text, content_type='text/plain')
        filename = f'student_report_{days}day_{end_date.strftime("%Y%m%d")}.txt'
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        return response

    def generate_daily_report(self, request, queryset):
        """Generate a report for the last 24 hours"""
        return self._generate_report(request, queryset, days=1)
    generate_daily_report.short_description = "üìä Generate Daily Report (24 hours)"

    def generate_weekly_report(self, request, queryset):
        """Generate a report for the last 7 days"""
        return self._generate_report(request, queryset, days=7)
    generate_weekly_report.short_description = "üìä Generate Weekly Report (7 days)"


@admin.register(QuestionAttempt)
class QuestionAttemptAdmin(admin.ModelAdmin):
    list_display = ('student', 'question', 'question_part', 'score_awarded', 'is_correct', 'attempted_at')
    list_filter = ('is_correct', 'attempted_at')
    search_fields = ('student__user__username', 'question__id')
    readonly_fields = ('attempted_at', 'marks_awarded')


@admin.register(RegistrationCode)
class RegistrationCodeAdmin(admin.ModelAdmin):
    list_display = ('code', 'is_active', 'times_used', 'max_uses', 'description', 'created_at')
    list_filter = ('is_active', 'created_at')
    search_fields = ('code', 'description')
    readonly_fields = ('times_used', 'created_at')

    fieldsets = (
        ('Code Information', {
            'fields': ('code', 'description')
        }),
        ('Usage Settings', {
            'fields': ('is_active', 'max_uses', 'times_used')
        }),
        ('Metadata', {
            'fields': ('created_at', 'created_by')
        }),
    )

    actions = ['deactivate_codes', 'activate_codes']

    def deactivate_codes(self, request, queryset):
        queryset.update(is_active=False)
        self.message_user(request, f"{queryset.count()} code(s) deactivated.")
    deactivate_codes.short_description = "Deactivate selected codes"

    def activate_codes(self, request, queryset):
        queryset.update(is_active=True)
        self.message_user(request, f"{queryset.count()} code(s) activated.")
    activate_codes.short_description = "Activate selected codes"


@admin.register(LoginHistory)
class LoginHistoryAdmin(admin.ModelAdmin):
    list_display = ('status_icon', 'username_attempted', 'user_link', 'timestamp', 'ip_address', 'short_user_agent')
    list_filter = ('success', 'timestamp')
    search_fields = ('username_attempted', 'user__username', 'ip_address')
    readonly_fields = ('user', 'username_attempted', 'timestamp', 'success', 'ip_address', 'user_agent', 'session_key')
    date_hierarchy = 'timestamp'

    def has_add_permission(self, request):
        # Prevent manual creation - should only be created by signals
        return False

    def has_change_permission(self, request, obj=None):
        # Make records read-only
        return False

    def status_icon(self, obj):
        if obj.success:
            return format_html('<span style="color: green; font-size: 16px;">‚úì</span>')
        return format_html('<span style="color: red; font-size: 16px;">‚úó</span>')
    status_icon.short_description = 'Status'

    def user_link(self, obj):
        if obj.user:
            return format_html('<a href="/admin/auth/user/{}/change/">{}</a>', obj.user.id, obj.user.username)
        return '-'
    user_link.short_description = 'User'

    def short_user_agent(self, obj):
        if len(obj.user_agent) > 50:
            return obj.user_agent[:50] + '...'
        return obj.user_agent
    short_user_agent.short_description = 'Browser/Device'


@admin.register(UserSession)
class UserSessionAdmin(admin.ModelAdmin):
    list_display = ('user_link', 'login_time', 'last_activity', 'time_active', 'ip_address', 'short_user_agent', 'is_active_display')
    list_filter = ('login_time', 'last_activity')
    search_fields = ('user__username', 'ip_address')
    readonly_fields = ('user', 'session_key', 'ip_address', 'user_agent', 'login_time', 'last_activity')
    date_hierarchy = 'login_time'

    def has_add_permission(self, request):
        # Prevent manual creation - should only be created by signals
        return False

    def has_change_permission(self, request, obj=None):
        # Make records read-only
        return False

    def user_link(self, obj):
        return format_html('<a href="/admin/auth/user/{}/change/">{}</a>', obj.user.id, obj.user.username)
    user_link.short_description = 'User'

    def time_active(self, obj):
        duration = timezone.now() - obj.login_time
        hours = duration.total_seconds() // 3600
        minutes = (duration.total_seconds() % 3600) // 60
        if hours > 0:
            return f"{int(hours)}h {int(minutes)}m"
        return f"{int(minutes)}m"
    time_active.short_description = 'Duration'

    def is_active_display(self, obj):
        if obj.is_active():
            return format_html('<span style="color: green;">‚óè</span> Active')
        return format_html('<span style="color: gray;">‚óã</span> Expired')
    is_active_display.short_description = 'Status'

    def short_user_agent(self, obj):
        if len(obj.user_agent) > 50:
            return obj.user_agent[:50] + '...'
        return obj.user_agent
    short_user_agent.short_description = 'Browser/Device'

    actions = ['terminate_sessions']

    def terminate_sessions(self, request, queryset):
        from django.contrib.sessions.models import Session
        count = 0
        for user_session in queryset:
            try:
                session = Session.objects.get(session_key=user_session.session_key)
                session.delete()
                count += 1
            except Session.DoesNotExist:
                pass
        self.message_user(request, f"{count} session(s) terminated.")
    terminate_sessions.short_description = "Terminate selected sessions"
